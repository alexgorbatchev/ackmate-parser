{"version":3,"sources":["ackmate-parser.js"],"names":["length","stream","filename","tail","surroundLine","matchLine","push","data","processLine","line","lineNumber","matches","value","slice","match","index","transform","encoding","callback","toString","hasTail","lines","split","pop","Array","from","flush","obj"],"mappings":";;;;;;kBAEe,YAAY;AACzB,MAAIA,eAAJ;AAAA,MAAYC,eAAZ;AACA,MAAIC,WAAW,IAAf;AACA,MAAIC,OAAO,IAAX;AACA,MAAMC,eAAe,cAArB;AACA,MAAMC,YAAY,0BAAlB;AACA,MAAMC,OAAO,SAAPA,IAAO;AAAA,WAAQL,OAAOK,IAAP,CAAYC,IAAZ,CAAR;AAAA,GAAb;;AAEA,WAASC,WAAT,CAAqBC,IAArB,EAA2B;AACzB,QAAIC,mBAAJ;AAAA,QAAgBC,gBAAhB;AAAA,QAAyBC,cAAzB;;AAEA,QAAIH,KAAK,CAAL,MAAY,GAAhB,EAAqB;AACnBP,iBAAWO,KAAKI,KAAL,CAAW,CAAX,CAAX;AACA,aAAOP,KAAK,EAAEJ,kBAAF,EAAL,CAAP;AACD,KAHD,MAGO,IAAIS,UAAUF,KAAKK,KAAL,CAAWV,YAAX,CAAd,EAAwC;AAC7CM,mBAAaC,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAb;AACAY,cAAQD,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAR;AACA,aAAOM,KAAK,EAAEJ,kBAAF,EAAYQ,sBAAZ,EAAwBE,YAAxB,EAAL,CAAP;AACD,KAJM,MAIA,IAAID,UAAUF,KAAKK,KAAL,CAAWT,SAAX,CAAd,EAAqC;AAC1C,UAAMU,QAAQJ,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAd;AACAU,mBAAaC,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAb;AACAA,eAASW,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAT;AACAY,cAAQD,QAAQA,QAAQX,MAAR,GAAiB,CAAzB,CAAR;AACA,aAAOM,KAAK,EAAEJ,kBAAF,EAAYQ,sBAAZ,EAAwBK,YAAxB,EAA+Bf,cAA/B,EAAuCY,YAAvC,EAAL,CAAP;AACD;AACF;;AAED,WAASI,SAAT,CAAmBT,IAAnB,EAAyBU,QAAzB,EAAmCC,QAAnC,EAA6C;AAC3CX,WAAOA,KAAKY,QAAL,EAAP;;AAEA,QAAIhB,QAAQ,IAAZ,EAAkB;AAChBI,aAAOJ,OAAOI,IAAd;AACD;;AAED,QAAIa,UAAUb,KAAKA,KAAKP,MAAL,GAAc,CAAnB,MAA0B,IAAxC;AACA,QAAIqB,QAAQd,KAAKe,KAAL,CAAW,IAAX,CAAZ;;AAEAnB,WAAQiB,WAAWC,MAAME,GAAN,EAAZ,IAA4B,IAAnC;;AAV2C;AAAA;AAAA;;AAAA;AAY3C,2BAAiBC,MAAMC,IAAN,CAAWJ,KAAX,CAAjB,8HAAoC;AAAA,YAA3BZ,IAA2B;;AAClCD,oBAAYC,IAAZ;AACD;AAd0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgB3C,WAAOS,UAAP;AACD;;AAED,WAASQ,KAAT,CAAeR,QAAf,EAAyB;AACvB,QAAIf,QAAQ,IAAZ,EAAkB;AAChBK,kBAAYL,IAAZ;AACD;AACD,WAAOe,UAAP;AACD;;AAED,SAAOjB,SAAS,kBAAS0B,GAAT,CAAaX,SAAb,EAAwBU,KAAxB,CAAhB;AACD,C;;AAxDD;;;;;;AAwDC","file":"ackmate-parser.js","sourcesContent":["import through2 from 'through2';\n\nexport default function () {\n  let length, stream;\n  let filename = null;\n  let tail = null;\n  const surroundLine = /^(\\d+):(.*)$/;\n  const matchLine = /^(\\d+);(\\d+) (\\d+):(.*)$/;\n  const push = data => stream.push(data);\n\n  function processLine(line) {\n    let lineNumber, matches, value;\n\n    if (line[0] === ':') {\n      filename = line.slice(1);\n      return push({ filename });\n    } else if (matches = line.match(surroundLine)) {\n      lineNumber = matches[matches.length - 2];\n      value = matches[matches.length - 1];\n      return push({ filename, lineNumber, value });\n    } else if (matches = line.match(matchLine)) {\n      const index = matches[matches.length - 3];\n      lineNumber = matches[matches.length - 4];\n      length = matches[matches.length - 2];\n      value = matches[matches.length - 1];\n      return push({ filename, lineNumber, index, length, value });\n    }\n  }\n\n  function transform(data, encoding, callback) {\n    data = data.toString();\n\n    if (tail != null) {\n      data = tail + data;\n    }\n\n    let hasTail = data[data.length - 1] !== '\\n';\n    let lines = data.split('\\n');\n\n    tail = (hasTail && lines.pop()) || null;\n\n    for (let line of Array.from(lines)) {\n      processLine(line);\n    }\n\n    return callback();\n  }\n\n  function flush(callback) {\n    if (tail != null) {\n      processLine(tail);\n    }\n    return callback();\n  }\n\n  return stream = through2.obj(transform, flush);\n};\n"]}